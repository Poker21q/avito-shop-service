# avito-shop-service

A service designed for internal use, enabling employees to exchange virtual coins and purchase corporate merch with them.

## Архитектура

Приложение спроектировано с использованием принципов **SOLID** и **чистой архитектуры**, организовано по слоям:

- **app**: содержит основные компоненты и инициализацию приложения.
- **web**: слой для обработки HTTP-запросов, включая роутинг и middleware.
- **service**: бизнес-логика, реализующая функциональные операции.
- **repository**: слой взаимодействия с базой данных, ответственный за выполнение SQL-запросов.

Каждый слой изолирован и не имеет прямой зависимости от других слоев. Пример зависимостей:
- Слой **web** зависит от сервисов.
- Слой **service** зависит от репозиториев.

Используется **Dependency Injection (DI)** для передачи интерфейсов между слоями.

## Особенности реализации

1. **DTO на каждом слое**: используются разные структуры данных (DTO) для взаимодействия между слоями. Это помогает поддерживать четкое разделение данных и логики.

2. **Sentinel Errors**: ошибки агрегируются на уровне репозитория с использованием `errors.Join`, и на других слоях обрабатываются через `errors.Is`. В результате, слой **web** может извлечь и вернуть пользователю только ту часть ошибки, которая имеет отношение к запросу.

3. **Логирование**: ошибки и стеки вызова записываются в логах в формате **ELK**. Для обработки паники используется middleware **recovery**, которое перехватывает паники и возвращает статус 500 с подробным логированием.

4. **База данных**:
   - Для операций с базой данных используется уровни изоляции **SERIALIZABLE** (для переводов и покупок) и **REPEATABLE READ** (для получения данных о пользователях).
   - Плейсхолдеры в SQL-запросах используются для предотвращения SQL-инъекций.
   - Для предотвращения излишней нагрузки при множественных запросах на чтение данных используется паттерн **SingleFlight**.

## Проблемы реализации

### Отхождения от принципа S (Single Responsibility):

- **Логирование в обработчиках запросов**: на данный момент логирование выполняется в обработчиках, что выходит за пределы их ответственности. Я пытался перенести логирование в middleware, но столкнулся с трудностями. Одной из идей было использование обертки для `http.ResponseWriter`, но не получилось, так как не хотелось передавать полный стек вызова ошибки пользователю.
- **Бизнес-логика на уровне базы данных**: первоначально не удалось изолировать транзакционную логику от репозитория. Решение через паттерн **UnitOfWork** не было реализовано из-за нехватки времени.

### Отхождения от принципа D (Dependency Inversion):

- **Зависимость от драйвера `database/sql` в репозитории**: в репозитории существует зависимость от драйвера, что затрудняет создание универсального интерфейса для выполнения запросов как внутри транзакции, так и вне её.

1. Запуск:

   ```bash
   make run

2. Тесты:

   ```bash
   make test

3. Покрытие:

   ```bash
   cover


